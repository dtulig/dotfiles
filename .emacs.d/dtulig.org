* Starter Kit Specifics
 - Load starter kit modules.
   #+BEGIN_SRC emacs-lisp
     (starter-kit-load "eshell")
     (starter-kit-load "lisp")
     (starter-kit-load "misc")
     (starter-kit-load "misc-recommended")
     (starter-kit-load "org")
     (starter-kit-load "yasnippet")
   #+END_SRC

* ELPA Packages

#+BEGIN_SRC emacs-lisp
  (starter-kit-install-if-needed
   'clojure-mode
   'clojurescript-mode
   'cider
   'auto-complete
   'ac-nrepl
   'go-mode
   'exec-path-from-shell
   'haskell-mode
   'ghc
   'flycheck
   'flycheck-haskell
   'helm
   'projectile
   'helm-projectile
   'org-projectile
   'js2-mode
   'web-mode
   'nix-mode
   'rust-mode
   'company)
#+END_SRC

* Misc Settings
 - If in a terminal, use the eww browser.
   #+BEGIN_SRC emacs-lisp
     (when (not (display-graphic-p))
       (setq browse-url-browser-function 'eww-browse-url))
   #+END_SRC

 - Remove scrollbars.
   #+BEGIN_SRC emacs-lisp
     (scroll-bar-mode -1)
   #+END_SRC

 - Load solarized theme.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'custom-theme-load-path "~/.emacs.d/non-elpa/emacs-color-theme-solarized")
     (load-theme 'solarized t)
   #+END_SRC

 - Show better el stack traces.
   #+BEGIN_SRC emacs-lisp
     (setq stack-trace-on-error t)
   #+END_SRC

 - On linux machines, the font size is small. This bumps it up to
   something more readable while leaving it as the default for mac.
   #+BEGIN_SRC emacs-lisp
     (when (not (memq window-system '(mac ns)))
       (set-face-attribute 'default nil :height 110))
   #+END_SRC

 - When on a mac, make sure to load exec-path-from-shell to get the
   PATH loaded into emacs.
   #+BEGIN_SRC emacs-lisp
     (when (memq window-system '(mac ns))
         (exec-path-from-shell-initialize))
   #+END_SRC

 - Put the non-elpa directory on the load path.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/non-elpa")
   #+END_SRC

 - Set the last seen setup instructions for magit.
   #+BEGIN_SRC emacs-lisp
     (setq magit-last-seen-setup-instructions "1.4.0")
   #+END_SRC

 - Remove extra whitespace on save.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

 - Enable midnight mode to clean old buffers.
   #+BEGIN_SRC emacs-lisp
     (require 'midnight)
     (midnight-delay-set 'midnight-delay "4:30am")
   #+END_SRC

 - Use emacs terminfo.
   #+BEGIN_SRC emacs-lisp
     (setq system-uses-terminfo nil)
   #+END_SRC

* Helm
#+BEGIN_SRC emacs-lisp
  (require 'helm)
  (require 'helm-config)

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  (helm-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
  (global-set-key (kbd "C-c h x") 'helm-register)
  (global-set-key (kbd "C-c h g") 'helm-google-suggest)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z") 'helm-select-action)
#+END_SRC

** Settings
#+BEGIN_SRC emacs-lisp
  (setq helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t
        helm-lisp-fuzzy-completion t)
#+END_SRC

* Company Mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  (global-company-mode)

  (defvar company-mode/enable-yas t "Enable yasnippet for all backends.")

  (defun add-pcomplete-to-capf ()
    (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))

  (add-hook 'org-mode-hook #'add-pcomplete-to-capf)

  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend)    (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

  (defun indent-or-complete ()
    (interactive)
    (if (looking-at "\\_>")
        (company-complete-common)
      (indent-according-to-mode)))

  (global-set-key "\t" 'indent-or-complete)
#+END_SRC

* Email and mu4e
#+BEGIN_SRC emacs-lisp
  (when (or (file-exists-p "/var/run/current-system/sw/share/emacs/site-lisp/mu4e")
            (file-exists-p "/usr/local/share/emacs/site-lisp/mu4e"))
    (add-to-list 'load-path "/var/run/current-system/sw/share/emacs/site-lisp/mu4e")
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")

    (require 'mu4e)
    (require 'org-mu4e)

    (setq mu4e-maildir "~/.mail/gmail")
    (setq mu4e-drafts-folder "/[Gmail].Drafts")
    (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
    (setq mu4e-trash-folder  "/[Gmail].Trash")
    (setq mu4e-refile-folder "/ImapArchive")

    (setq mu4e-headers-sort-direction 'ascending)

    (require 'mu4e-contrib)
    (setq mu4e-html2text-command 'mu4e-shr2text)
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-sent-messages-behavior 'delete)

    (add-hook 'mu4e-compose-mode-hook (lambda () (set-fill-column 70)))

    (setq mu4e-maildir-shortcuts
        '( ("/INBOX"               . ?i)
           ("/[Gmail].Sent Mail"   . ?s)
           ("/[Gmail].Trash"       . ?t)
           ("/[Gmail].All Mail"    . ?a)))

    (fset 'my-move-to-trash "mt")
    (define-key mu4e-headers-mode-map (kbd "d") 'my-move-to-trash)
    (define-key mu4e-view-mode-map (kbd "d") 'my-move-to-trash)

    (fset 'my-archive "D")
    (define-key mu4e-headers-mode-map (kbd "e") 'my-archive)
    (define-key mu4e-view-mode-map (kbd "e") 'my-archive)

    (setq mu4e-get-mail-command "mbsync -a")
      (setq mu4e-bookmarks
            '(
              ("(flag:unread AND NOT (flag:trashed OR maildir:\"/[Gmail].Trash\") AND NOT ((maildir:\"/[Gmail].Spam\") OR (maildir:\"/[Gmail].All Mail\") OR (maildir:\"/[Gmail].Important\")) OR maildir:\"/[Gmail].Inbox\""
               "Daily Review" ?d)
              ("flag:unread AND NOT (flag:trashed OR maildir:\"/[Gmail].Trash\") AND NOT list:* AND NOT maildir:\"/[Gmail].Spam\""
               "Unread messages, no lists" ?U)
              ("flag:unread AND NOT (flag:trashed OR maildir:\"/[Gmail].Trash\") AND NOT maildir:\"/[Gmail].Spam\""
               "All unread messages" ?u)
              ("flag:unread AND list:* AND NOT maildir:\"/[Gmail].Spam\" AND NOT maildir:\"/[Gmail].Trash\""
               "Unread lists" ?l)
              ("date:today..now"                  "Today's messages"     ?t)
              ("date:7d..now"                     "Last 7 days"          ?w)
              ("mime:image/*"                     "Messages with images" ?p)))

    (require 'smtpmail)

    (defun read-lines (filePath)
      "Return a list of lines of a file at filePath."
      (with-temp-buffer
        (insert-file-contents filePath)
        (split-string (buffer-string) "\n" t)))

    (defun get-string-from-file (filePath)
      "Return filePath's file content."
      (with-temp-buffer
        (insert-file-contents filePath)
            (buffer-string)))

    (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-stream-type 'starttls
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

    (setq message-kill-buffer-on-exit t)

    (defun org-mu4e-store-link ()
      "Store a link to a mu4e query or message."
      (cond
       ;; storing links to queries
       ((eq major-mode 'mu4e-headers-mode)
        (let* ((query (mu4e-last-query))
               desc link)
          (org-store-link-props :type "mu4e" :query query)
          (setq
           desc (concat "mu4e:query:" query)
           link desc)
          (org-add-link-props :link link :description desc)
          link))
       ;; storing links to messages
       ((eq major-mode 'mu4e-view-mode)
        (let* ((msg  (mu4e-message-at-point))
               (msgid   (or (plist-get msg :message-id) "<none>"))
               (from (car (car (mu4e-message-field msg :from))))
               (to (car (car (mu4e-message-field msg :to))))
               (subject (mu4e-message-field msg :subject))
               link)
          (setq link (concat "mu4e:msgid:" msgid))
          (org-store-link-props :type "mu4e" :link link
                                :message-id msgid)
          (setq link (concat "mu4e:msgid:" msgid))
          (org-store-link-props
           :type "mu4e" :from from :to to :subject subject
           :message-id msgid)

          (org-add-link-props :link link
                              :description (funcall org-mu4e-link-desc-func msg))
          link))))

    (org-add-link-type "mu4e" 'org-mu4e-open)
    (add-hook 'org-store-link-functions 'org-mu4e-store-link)

    (add-to-list 'mu4e-view-actions '("rview related" . djr/mu4e-view-related-search) t)
    (defun djr/mu4e-view-related-search (msg)
      "Search for related messages to the current one"
      (let* ((msgid (mu4e-msg-field msg :message-id)))
        (setq mu4e-headers-include-related t)
        (mu4e-headers-search (concat "msgid:" msgid))))
  )
#+END_SRC

* Mode Customizations
** Nix
#+BEGIN_SRC emacs-lisp
  (require 'nix-mode)
#+END_SRC
** Org
#+BEGIN_SRC emacs-lisp
  (setq org-directory (expand-file-name "~/Sync/org/"))

  (setq org-log-done 'time)
  (global-set-key "\C-cl" 'org-store-link)
  (setq org-default-notes-file (concat org-directory "/notes.org"))
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)

  (setq org-refile-use-outline-path 'nil)

  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

  (setq org-clock-in-resume t)
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
  (setq org-clock-into-drawer t)
  (setq org-clock-out-remove-zero-time-clocks t)
  (setq org-clock-out-when-done t)

  (defun dt/org-reload ()
    (interactive)
    (setq org-agenda-files (append (file-expand-wildcards (concat org-directory "dates/*.org"))
                                   (file-expand-wildcards (concat org-directory "*.org"))
                                   (file-expand-wildcards (concat org-directory "indeed/dates/*.org"))
                                   (file-expand-wildcards (concat org-directory "indeed/*.org"))))
    (setq org-default-personal-notes-file
          (concat org-directory "dates/"
                  (downcase (format-time-string "%Y-%B-p.org"))))
    (setq org-default-work-notes-file
          (concat org-directory "indeed/dates/"
                  (downcase (format-time-string "%Y-%B-w.org")))))

  (dt/org-reload)

  (setq org-capture-templates
        '(("t" "Todo (Work)" entry (file+headline
                              org-default-work-notes-file "Tasks")
           "* TODO %^{Description}
  %U
  %?
  " :clock-in t :clock-resume t)

          ("r" "Respond (Work)" entry (file+headline
                              org-default-work-notes-file "Tasks")
                 "* NEXT Respond to %:from on %:subject
  SCHEDULED: %t
  %U
  %a
  " :clock-in t :clock-resume t :immediate-finish t)
          ("p" "Todo (Personal)" entry (file+headline
                              org-default-personal-notes-file "Tasks")
           "* TODO %^{Description}
  %U
  %?
  " :clock-in t :clock-resume t)
          ("e" "Respond (Personal)" entry (file+headline
                              org-default-personal-notes-file "Tasks")
                 "* NEXT Respond to %:from on %:subject
  SCHEDULED: %t
  %U
  %a
  " :clock-in t :clock-resume t :immediate-finish t)
          ("n" "Note" entry (file+headline
                              org-default-personal-notes-file "Notes")
                 "* %? :NOTE:
  %U
  " :clock-in t :clock-resume t)
          ("j" "Journal" entry (file+datetree (concat org-directory "/journal.org"))
                 "* %^{Title}
  %U
  %?
  " :clock-in t :clock-resume t)
          ("l" "Log Time" entry (file+datetree
                                 (concat org-directory "/timelog.org"))
           "** %U - %^{Activity}  :TIME:")
          ("m" "Meeting" entry (file+headline
                                org-default-work-notes-file "Meetings")
                 "* MEETING with %^{Description} :MEETING:
  %U
  %?" :clock-in t :clock-resume t)))

  (setq org-refile-targets (quote ((nil :maxlevel . 4)
                                   (org-agenda-files :maxlevel . 4))))

  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))

  (setq org-agenda-span 'day)

  (add-hook 'org-agenda-mode-hook
            (lambda ()
              (add-hook 'auto-save-hook 'org-save-all-org-buffers nil t)
              (auto-save-mode)))

  (require 'cl)

  (defun buffer-major-mode-org-mode-p (buffer)
    (string= "org-mode" (with-current-buffer buffer major-mode)))

  ;; When refreshing the org mode window, occasionally a file will have
  ;; shifted underneath the current instance of emacs. This function
  ;; will close all org-mode buffers.
  (defun org-close-all-org-buffers ()
    (interactive)
    (mapcar #'kill-buffer
            (remove-if-not #'buffer-major-mode-org-mode-p (buffer-list))))

  ;; This is a global key to close all org mode buffers.
  ;(global-set-key "\C-c\C-g" 'org-close-all-org-buffers)

  (defun org-agenda-redo-with-close-buffers ()
    (interactive)
    (org-close-all-org-buffers)
    (org-agenda-redo t))

  ;: This remaps "g" to close all org mode buffers and then call agenda
  ;; redo. "r" still calls redo normally.
  (add-hook 'org-agenda-mode-hook
            (lambda ()
              (define-key org-agenda-mode-map "g" #'org-agenda-redo-with-close-buffers)))

  ;; I liked http://doc.norang.ca/org-mode.html#WhatDoIWorkOnNext,
  ;; taking some of that.

  (setq org-agenda-custom-commands
        (quote ((" " "Agenda"
                 ((agenda "" nil)
                  (tags-todo "-CANCELLED/!"
                             ((org-agenda-overriding-header "Stuck Projects")
                              (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                              (org-agenda-sorting-strategy
                               '(category-keep))))
                  (tags-todo "-HOLD-CANCELLED/!"
                             ((org-agenda-overriding-header "Projects")
                              (org-agenda-skip-function 'bh/skip-non-projects)
                              (org-tags-match-list-sublevels 'indented)
                              (org-agenda-sorting-strategy
                               '(category-keep))))
                  (tags-todo "-CANCELLED/!NEXT"
                             ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                              (org-tags-match-list-sublevels t)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(todo-state-down effort-up category-keep))))
                  (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                             ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-non-project-tasks)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(category-keep)))))
                  nil))))

#+END_SRC

*** Norang Customizations
#+BEGIN_SRC emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ;; ((org-is-habit-p)
         ;;  subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ;; ((org-is-habit-p)
         ;;  next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ;; ((org-is-habit-p)
         ;;  subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ;; ((org-is-habit-p)
         ;;  subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ;; ((org-is-habit-p)
         ;;  subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))

#+END_SRC
** Clojure
 - Initialization.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
     (setq nrepl-hide-special-buffers t)
     (add-hook 'cider-repl-mode-hook 'paredit-mode)
     (add-hook 'cider-repl-mode-hook 'auto-complete-mode)
   #+END_SRC
** GLSL
 - Initialization
   #+BEGIN_SRC emacs-lisp
     (autoload 'glsl-mode "glsl-mode" nil t)
     (add-to-list 'auto-mode-alist '("\\.glsl\\'" . glsl-mode))
     (add-to-list 'auto-mode-alist '("\\.vert\\'" . glsl-mode))
     (add-to-list 'auto-mode-alist '("\\.frag\\'" . glsl-mode))
     (add-to-list 'auto-mode-alist '("\\.geom\\'" . glsl-mode))
   #+END_SRC

** Go
 - Auto gfmt on save.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'gofmt-before-save)
   #+END_SRC
** Purescript
 - Initialization.
   #+BEGIN_SRC emacs-lisp
     ;; https://github.com/dysinger/purescript-mode
     ;; make EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs all
     ;; M-x update-directory-autoloads
     (add-to-list 'load-path "~/.emacs.d/non-elpa/purescript-mode")
     (require 'purescript-mode-autoloads)
     (add-hook 'purescript-mode-hook 'turn-on-purescript-indentation)
   #+END_SRC
** Haskell
 - Initialization
   #+BEGIN_SRC emacs-lisp
     (let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
       (setenv "PATH" (concat my-cabal-path ":" (getenv "PATH")))
       (add-to-list 'exec-path my-cabal-path))

     (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
     (add-hook 'haskell-mode-hook 'haskell-doc-mode)
     (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
     (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)

     ;; TODO Figure out if this is a better set of haskell defaults.
     ;(add-hook 'haskell-mode-hook 'haskell-indentation-mode)

     ;(autoload 'ghc-init "ghc" nil t)
     ;(autoload 'ghc-debug "ghc" nil t)
     ;(add-hook 'haskell-mode-hook (lambda () (ghc-init) (flymake-mode)))

     ;(require 'flycheck)
     ;(require 'flycheck-haskell)
     ;(add-hook 'haskell-mode-hook 'flycheck-mode)
     ;(add-hook 'flycheck-mode-hook 'flycheck-haskell-configure)

     ;(setq haskell-process-type 'stack-ghci)
     ;(setq haskell-process-path-ghci "stack")
     ;(setq haskell-process-args-ghci "ghci")

     (eval-after-load 'haskell-mode
       '(progn
          (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
          (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
          (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
          (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
          (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
          (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))

     (eval-after-load 'haskell-cabal
       '(progn
          (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
          (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
          (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
          (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))

     (setq haskell-process-wrapper-function
           (lambda (argv) (append (list "nix-shell" "-I" "." "--command")
                             (list (mapconcat 'identity argv " ")))))

   #+END_SRC
** Web
#+BEGIN_SRC elisp
  (require 'web-mode)
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))

  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-style-padding 2)
  (setq web-mode-script-padding 2)
#+END_SRC

* General Defuns
 - I disliked the order that it used for where to put auto save
   buffers that do not map to a file. The new change will first try to
   write to /tmp before going to the default directory, typically
   where emacs was loaded for buffers without files.
   #+BEGIN_SRC emacs-lisp
     (defun make-auto-save-file-name ()
       "Return file name to use for auto-saves of current buffer.
     Does not consider `auto-save-visited-file-name' as that variable is checked
     before calling this function.  You can redefine this for customization.
     See also `auto-save-file-name-p'."
       (if buffer-file-name
           (let ((handler (find-file-name-handler buffer-file-name
                                                  'make-auto-save-file-name)))
             (if handler
                 (funcall handler 'make-auto-save-file-name)
               (let ((list auto-save-file-name-transforms)
                     (filename buffer-file-name)
                     result uniq)
                 ;; Apply user-specified translations
                 ;; to the file name.
                 (while (and list (not result))
                   (if (string-match (car (car list)) filename)
                       (setq result (replace-match (cadr (car list)) t nil
                                                   filename)
                             uniq (car (cddr (car list)))))
                   (setq list (cdr list)))
                 (if result
                     (if uniq
                         (setq filename (concat
                                         (file-name-directory result)
                                         (subst-char-in-string
                                          ?/ ?!
                                          (replace-regexp-in-string "!" "!!"
                                                                    filename))))
                       (setq filename result)))
                 (setq result
                       (if (and (eq system-type 'ms-dos)
                                (not (msdos-long-file-names)))
                           ;; We truncate the file name to DOS 8+3 limits
                           ;; before doing anything else, because the regexp
                           ;; passed to string-match below cannot handle
                           ;; extensions longer than 3 characters, multiple
                           ;; dots, and other atrocities.
                           (let ((fn (dos-8+3-filename
                                      (file-name-nondirectory buffer-file-name))))
                             (string-match
                              "\\`\\([^.]+\\)\\(\\.\\(..?\\)?.?\\|\\)\\'"
                              fn)
                             (concat (file-name-directory buffer-file-name)
                                     "#" (match-string 1 fn)
                                     "." (match-string 3 fn) "#"))
                         (concat (file-name-directory filename)
                                 "#"
                                 (file-name-nondirectory filename)
                                 "#")))
                 ;; Make sure auto-save file names don't contain characters
                 ;; invalid for the underlying filesystem.
                 (if (and (memq system-type '(ms-dos windows-nt cygwin))
                          ;; Don't modify remote (ange-ftp) filenames
                          (not (string-match "^/\\w+@[-A-Za-z0-9._]+:" result)))
                     (convert-standard-filename result)
                   result))))

         ;; Deal with buffers that don't have any associated files.  (Mail
         ;; mode tends to create a good number of these.)

         (let ((buffer-name (buffer-name))
               (limit 0)
               file-name)
           ;; Restrict the characters used in the file name to those which
           ;; are known to be safe on all filesystems, url-encoding the
           ;; rest.
           ;; We do this on all platforms, because even if we are not
           ;; running on DOS/Windows, the current directory may be on a
           ;; mounted VFAT filesystem, such as a USB memory stick.
           (while (string-match "[^A-Za-z0-9-_.~#+]" buffer-name limit)
             (let* ((character (aref buffer-name (match-beginning 0)))
                    (replacement
                     ;; For multibyte characters, this will produce more than
                     ;; 2 hex digits, so is not true URL encoding.
                     (format "%%%02X" character)))
               (setq buffer-name (replace-match replacement t t buffer-name))
               (setq limit (1+ (match-end 0)))))
           ;; Generate the file name.
           (setq file-name
                 (make-temp-file
                  (let ((fname
                         (expand-file-name
                          (format "#%s#" buffer-name)
                          ;; Try a few alternative directories, to get one we can
                          ;; write it.
                          (cond
                           ((file-writable-p "/tmp/") "/tmp/")
                           ((file-writable-p default-directory) default-directory)
                           ((file-writable-p "/var/tmp/") "/var/tmp/")
                           ("~/")))))
                    (if (and (memq system-type '(ms-dos windows-nt cygwin))
                             ;; Don't modify remote (ange-ftp) filenames
                             (not (string-match "^/\\w+@[-A-Za-z0-9._]+:" fname)))
                        ;; The call to convert-standard-filename is in case
                        ;; buffer-name includes characters not allowed by the
                        ;; DOS/Windows filesystems.  make-temp-file writes to the
                        ;; file it creates, so we must fix the file name _before_
                        ;; make-temp-file is called.
                        (convert-standard-filename fname)
                      fname))
                  nil "#"))
           ;; make-temp-file creates the file,
           ;; but we don't want it to exist until we do an auto-save.
           (condition-case ()
               (delete-file file-name)
             (file-error nil))
           file-name)))

   #+END_SRC

 - Unfills a full paragraph.
   #+BEGIN_SRC emacs-lisp
     ;; From http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html
     (defun dt/fill-or-unfill ()
       "Like `fill-paragraph', but unfill if used twice."
       (interactive)
       (let ((fill-column
              (if (eq last-command 'dt/fill-or-unfill)
                  (progn (setq this-command nil)
                         (point-max))
                fill-column)))
         (call-interactively #'fill-paragraph)))

   #+END_SRC

* General Bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key [remap fill-paragraph]
                  #'dt/fill-or-unfill)
#+END_SRC
* Tmux Compatibility

I was having a tough time getting combinations like M-S-<right> to
work correctly in emacs under tmux. Here is a mapping that fixes this.

From: https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux

#+BEGIN_SRC emacs-lisp
  (if (getenv "TMUX")
      (progn
        (let ((x 2) (tkey ""))
          (while (<= x 8)
            ;; shift
            (if (= x 2)
                (setq tkey "S-"))
            ;; alt
            (if (= x 3)
                (setq tkey "M-"))
            ;; alt + shift
            (if (= x 4)
                (setq tkey "M-S-"))
            ;; ctrl
            (if (= x 5)
                (setq tkey "C-"))
            ;; ctrl + shift
            (if (= x 6)
                (setq tkey "C-S-"))
            ;; ctrl + alt
            (if (= x 7)
                (setq tkey "C-M-"))
            ;; ctrl + alt + shift
            (if (= x 8)
                (setq tkey "C-M-S-"))

            ;; arrows
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d A" x)) (kbd (format "%s<up>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d B" x)) (kbd (format "%s<down>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d C" x)) (kbd (format "%s<right>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d D" x)) (kbd (format "%s<left>" tkey)))
            ;; home
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d H" x)) (kbd (format "%s<home>" tkey)))
            ;; end
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d F" x)) (kbd (format "%s<end>" tkey)))
            ;; page up
            (define-key key-translation-map (kbd (format "M-[ 5 ; %d ~" x)) (kbd (format "%s<prior>" tkey)))
            ;; page down
            (define-key key-translation-map (kbd (format "M-[ 6 ; %d ~" x)) (kbd (format "%s<next>" tkey)))
            ;; insert
            (define-key key-translation-map (kbd (format "M-[ 2 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; delete
            (define-key key-translation-map (kbd (format "M-[ 3 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; f1
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d P" x)) (kbd (format "%s<f1>" tkey)))
            ;; f2
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d Q" x)) (kbd (format "%s<f2>" tkey)))
            ;; f3
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d R" x)) (kbd (format "%s<f3>" tkey)))
            ;; f4
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d S" x)) (kbd (format "%s<f4>" tkey)))
            ;; f5
            (define-key key-translation-map (kbd (format "M-[ 15 ; %d ~" x)) (kbd (format "%s<f5>" tkey)))
            ;; f6
            (define-key key-translation-map (kbd (format "M-[ 17 ; %d ~" x)) (kbd (format "%s<f6>" tkey)))
            ;; f7
            (define-key key-translation-map (kbd (format "M-[ 18 ; %d ~" x)) (kbd (format "%s<f7>" tkey)))
            ;; f8
            (define-key key-translation-map (kbd (format "M-[ 19 ; %d ~" x)) (kbd (format "%s<f8>" tkey)))
            ;; f9
            (define-key key-translation-map (kbd (format "M-[ 20 ; %d ~" x)) (kbd (format "%s<f9>" tkey)))
            ;; f10
            (define-key key-translation-map (kbd (format "M-[ 21 ; %d ~" x)) (kbd (format "%s<f10>" tkey)))
            ;; f11
            (define-key key-translation-map (kbd (format "M-[ 23 ; %d ~" x)) (kbd (format "%s<f11>" tkey)))
            ;; f12
            (define-key key-translation-map (kbd (format "M-[ 24 ; %d ~" x)) (kbd (format "%s<f12>" tkey)))
            ;; f13
            (define-key key-translation-map (kbd (format "M-[ 25 ; %d ~" x)) (kbd (format "%s<f13>" tkey)))
            ;; f14
            (define-key key-translation-map (kbd (format "M-[ 26 ; %d ~" x)) (kbd (format "%s<f14>" tkey)))
            ;; f15
            (define-key key-translation-map (kbd (format "M-[ 28 ; %d ~" x)) (kbd (format "%s<f15>" tkey)))
            ;; f16
            (define-key key-translation-map (kbd (format "M-[ 29 ; %d ~" x)) (kbd (format "%s<f16>" tkey)))
            ;; f17
            (define-key key-translation-map (kbd (format "M-[ 31 ; %d ~" x)) (kbd (format "%s<f17>" tkey)))
            ;; f18
            (define-key key-translation-map (kbd (format "M-[ 32 ; %d ~" x)) (kbd (format "%s<f18>" tkey)))
            ;; f19
            (define-key key-translation-map (kbd (format "M-[ 33 ; %d ~" x)) (kbd (format "%s<f19>" tkey)))
            ;; f20
            (define-key key-translation-map (kbd (format "M-[ 34 ; %d ~" x)) (kbd (format "%s<f20>" tkey)))

            (setq x (+ x 1))))))
#+END_SRC
* Emacs Server
Start the server for emacsclient -c usage.

#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC
